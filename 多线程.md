Javaå¤šçº¿ç¨‹å­¦ä¹ 
-----------------------
èµ„æ–™ğŸ—‚ï¸æ¥æºäºÂ èœé¸Ÿå­¦é™¢



å‰è¨€: Runnable/Consumer/Supply/Function æ˜¯æŠ½è±¡æ¥å£ã€‚



ä¸€ã€Thread ç±»åŸç”Ÿæ–¹æ³•

0. ç›¸å…³åŸºç¡€

â‘ å¯ä»¥ä½¿ç”¨æ¥å£å®ç°åç‰¹åŒ– implements Callable<Integer>; ç»§æ‰¿å­˜åœ¨ç±»å’Œå±æ€§ç»§æ‰¿

â‘¡new Callable() å®ç°call()

new FutureTask(Callable callable)

Callableå¯ä»¥ä½¿ç”¨è¶…ç±»

â‘¢FutureTask æ–¹æ³•: .get() <?> è¿”å›call()çš„è¿”å›å€¼

â‘£.getName() æ ¹æ®å¯¹è±¡è¿”å›ç‰¹å®šå®ä¾‹åŒ–å¯¹è±¡æ‰€å±ç±»å

1. å¿…è¦æ–¹æ³•

Thread(Runnable runnable,String ThreadName)

Thread(FutureTask futuretask,String ThreadName)

.start()å°±ç»ª-å¯åŠ¨çŠ¶æ€

.run()å¯åŠ¨çŠ¶æ€

.stop()/.destroy()æ­»äº¡çŠ¶æ€

2. è¾…åŠ©æ–¹æ³•

.setName(String name) final è®¾ç½®çº¿ç¨‹å

.isAlive() boolean å­˜æ´»çŠ¶æ€

.join(long milliseconds) é˜»éš”å½“å‰çº¿ç¨‹çš„millisecondsæ¯«ç§’

.interrupt() ä¸­æ–­çº¿ç¨‹

.setDaemon(boolean on) è®¾ç½®å½“å‰çº¿ç¨‹ä¸ºå®ˆæŠ¤çº¿ç¨‹

.setPriority(int priority) final

.yield() static æš‚åœå½“å‰çº¿ç¨‹ï¼Œæ‰§è¡Œå…¶å®ƒçº¿ç¨‹

.sleep(long milliseconds) æ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹ä¼‘çœ ï¼ˆæš‚åœæ‰§è¡Œï¼‰

.holdsLock()Â 

.currentThread() static Thread è¿”å›å½“å‰çº¿ç¨‹çš„å¼•ç”¨å¯¹è±¡

.dumpStack() static å½“å‰çš„å †æ ˆè·Ÿè¸ªå¯¼å…¥æ ‡å‡†é”™è¯¯æµ



äºŒã€çº¿ç¨‹æ± 

1.ç›¸å…³ç±»

Executors Callable(å®ç°ç±») ExecutorService Future(æ¥å£)

æ¥å£-å®ç°ç±»
ExecutorService-Executors 
Futureè¿”å›å€¼æ¥å£

2.å¿…è¦æ–¹æ³•

ExecutorService executorservice=newÂ Executors.newFixedThreadPool(int num)

.submit(Callable callable) Future<?>

.shutdown() å…³é—­/é‡Šæ”¾çº¿ç¨‹æ± 



3.åŸç†ç›´è§†

åˆ©ç”¨Executors.newFixedThreadPool(int num)åˆ›å»ºçº¿ç¨‹æ± å¯¹è±¡ï¼Œç„¶åä½¿ç”¨.submit(CallableÂ callable)ä¸Šä¼ å‡½æ•°å¯¹è±¡ï¼ŒåŒæ—¶æ‰§è¡Œå¹¶è¿”å›Futureæ¥å£å¯¹è±¡ï¼Œä½¿ç”¨.get()è·å–è¿”å›å€¼



ä¸‰ã€é”ğŸ”’

1.ç±»/è¯­æ³•

Lock-Reentrantlock
Synchronized åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨

2.å¿…è¦æ–¹æ³•
.lock() 
.unlock()



